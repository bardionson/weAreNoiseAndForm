// SPDX-License-Identifier: MIT
// solhint-disable-next-line
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// @author: Bård Ionson
// @website: bardIonson.com
// 
// We Are Noise & Form - generative on-chain art
// A unique NFT contract that generates and mints two NFTs on demand. One goes to the minter and the other goes to the previous minter. They have the same shape but different backgrounds.
// The minter gets "We Are Noise"
// The previous minter gets a twin called "We Are Form"
// Warning if too many mints happen at once it may send the NFT to the wrong wallet because of the eventual consistancy of a distributed network.
// Inspired by Robness We Are Noise

contract WeAreNoiseAndForm is ERC721, ERC721URIStorage, ERC721Burnable, ERC721Royalty, ReentrancyGuard, Ownable{
    using Counters for Counters.Counter;
    uint256 public mintPrice;
    uint8 public randomsUsed;
    uint8 public randomsLoaded;
    uint16 public maxSupply = 256;
    mapping(uint256 => address) private mintedAddress;

    struct RandomArt {
        string[3] m;
        string n;
        string p;
    }

    struct NumberParts {
        string[16] parts;
        uint[16] numP;
    }

    mapping(uint256 => RandomArt) internal randomArts;

    Counters.Counter private _tokenIdCounter;
    constructor() ERC721("We Are Noise And Form on-chain generative art", "WANF")  {
        _setDefaultRoyalty(0x72774bc572ef9a2dFF47c3F8Cc200DC2fe3830C0,500);
        mintPrice = 20000000000000000;
        mintedAddress[0]=msg.sender;
    }

    function setMintPrice(uint256 _newPrice) public onlyOwner {
        mintPrice = _newPrice;
    }
  
    function createRandomPub(uint[] memory _randomSeed) public onlyOwner {
            createRandom(_randomSeed);
    }

    function createRandom(uint[] memory _randomSeed) internal onlyOwner  {
        NumberParts memory division;
        uint seed;
        for (uint256 i = 0; i < _randomSeed.length; ++i) {
            seed = uint(keccak256(abi.encodePacked(_randomSeed[i], block.timestamp,block.prevrandao, msg.sender)));
            division = divide(seed);
            randomArts[randomsLoaded].n = concatenate(division.parts);
            randomArts[randomsLoaded].m[0] = matrix(division.numP[0]);
            randomArts[randomsLoaded].m[1] = matrix(division.numP[1]);
            randomArts[randomsLoaded].m[2] = matrix(division.numP[2]);
            randomArts[randomsLoaded].p = calcPath(seed);
            randomsLoaded++;
        }
    }

    function svgToImageURI(string memory svg)
        internal
        pure
        returns (string memory)
    {
        string memory baseURL = "data:image/svg+xml;base64,";
        string memory svgBase64Encoded = Base64.encode(bytes(svg));
        return string(abi.encodePacked(baseURL, svgBase64Encoded));
    }

    function formatTokenURI(string memory imageURI, string memory artist, string memory artType)
        internal pure
        returns (string memory)
    {
        return
            string(
                abi.encodePacked(
                    "data:application/json;base64,",
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                unicode'{"name": "We Are Noise and Form", "created_by" : "Bård Ionson", "description": "',artType, ' by Bard Ionson on-chain generative art exporing entropy and chaos. Images are generated by the contract and stored on-chain. Limit 3 per wallet." , "image":"',
                                imageURI,
                                '","attributes": [{"trait_type": "Artist","value":"',artist,'"},{"trait_type": "Type","value":"',artType,'"}]}'
                            )
                        )
                    )
                )
            );
    }
    
    function appendString(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e, string memory _f, string memory _g, string memory _h, string memory _i, string memory _j, string memory _k) internal pure returns (string memory)  {
        return string(abi.encodePacked(_a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k));
    }

    function mint(address _to) public payable nonReentrant {
        require(_tokenIdCounter.current() < maxSupply && randomsUsed < randomsLoaded && balanceOf(msg.sender) < 4 && msg.value >= mintPrice, "No Price or inventory");
        //require(balanceOf(msg.sender) < 4, "Max 3");
        //require(msg.value >= mintPrice, "low price");
        //require(randomsUsed < randomsLoaded, "paused");
        RandomArt memory oneArt = randomArts[randomsUsed];
        randomsUsed++;
        
        string memory theObj = appendString(unicode"<svg viewBox='0 0 4e3 2250' xmlns='http://www.w3.org/2000/svg'><filter id='static'><feTurbulence type='turbulence' baseFrequency='0.99' numOctaves='10' result='turbulence'><animate id='sd' attributeName='seed' dur='2s' values='", oneArt.n,"' repeatCount='indefinite'/></feTurbulence><feColorMatrix type='saturate' values='1' result='saturate'/><feComponentTransfer><feFuncR id='r' type='discrete' tableValues='",oneArt.m[0],"'/><feFuncG id='g' type='discrete' tableValues='", oneArt.m[1],"'/><feFuncB id='b' type='discrete' tableValues='",oneArt.m[2],"'/><feFuncA type='discrete' tableValues='1 1'/></feComponentTransfer></filter><rect width='100%' height='100%' filter='url(#static)'/><path id='MP' fill='red' stroke='red' stroke-width='9' d='", oneArt.p ,"'><animate id='MP' attributeName='fill' dur='20s' values='red;red;green;gold;blue;black;white;green;red' repeatCount='indefinite'/></path></svg>");
        string memory imageURI = svgToImageURI(theObj);
        string memory uri = formatTokenURI(imageURI, "Bard Ionson", "We Are Noise");

        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(_to, tokenId);
        _setTokenURI(tokenId, uri);

        mintedAddress[randomsUsed] = _to;
        theObj = string(abi.encodePacked(unicode"<svg viewBox='0 0 4e3 2250' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' fill='black'/><path id='MP' fill='red' stroke='red' stroke-width='9' d='", oneArt.p ,"'><animate id='MP' attributeName='fill' dur='20s' values='red;red;green;gold;blue;black;white;green;red' repeatCount='indefinite'/></path></svg>"));
        imageURI = svgToImageURI(theObj);
        uri = formatTokenURI(imageURI, "Bard Ionson", "We Are Form");
        address _share_to = mintedAddress[randomsUsed-1];

        _tokenIdCounter.increment();
        _safeMint(_share_to,tokenId+1);
        _setTokenURI(tokenId+1, uri);
    }

    function calcPath(uint256 endpoint) internal pure returns (string memory) {
        // Split the number into groups of 4 digits
        uint256[] memory groups = new uint256[](20);
        uint256 counter = 0;
        uint256 num = endpoint;
        while (num > 0) {
            groups[counter] = num % 10000;
            num = num / 10000;
            counter++;
        }
        
        // Scale down the coordinates to fit within an SVG viewport and round to the nearest integer
        uint256[] memory x = new uint256[](10);
        uint256[] memory y = new uint256[](10);
        for (uint256 i = 0; i < 10; i++) {
            x[i] = (groups[i] * 4000) / 10000;
            y[i] = (groups[i+10] * 2250) / 10000;
        }

        // Create an SVG path string that draws a line through the defined points
        string memory svgPath = string(abi.encodePacked("M", Strings.toString(x[0]), ",", Strings.toString(y[0])));
        for (uint256 i = 1; i < 10; i++) {
            svgPath = string(abi.encodePacked(svgPath, " L", Strings.toString(x[i]), ",", Strings.toString(y[i])));
        }
        return svgPath;
    }

    function divide(uint256 number) internal pure returns (NumberParts memory) {
        NumberParts memory division;
        for (uint i = 0; i < 16; i++) {
            uint theNum = number % 100000;
            division.parts[i] = Strings.toString(theNum);
            division.numP[i] = theNum;
            number = number / 100000;
        }
        return division;
    }

    function concatenate(string[16] memory arr) internal pure returns (string memory) {
        string memory result = "";
        for (uint i = 0; i < arr.length-3; i++) {
            if (i==0) {
                result = arr[i];
            } else {
                result = string.concat(result, ";", arr[i]);
            }
        }
        return result;
    }

    function matrix(uint initial) internal pure returns (string memory) {
        string memory matrixVar;
        string memory a = Strings.toString((initial % 10)%2);
        string memory b = Strings.toString((initial % 100 / 10)%2);
        string memory c = Strings.toString((initial % 1000 / 100)%2);
        string memory d = Strings.toString((initial % 10000 / 1000)%2);
        string memory e = Strings.toString((initial % 100000 / 10000)%2);
        matrixVar = string(abi.encodePacked(a," ",b," ",c," ",d," ",e));
        return matrixVar;
    }

    function withdraw() public onlyOwner nonReentrant {
        // This will transfer the remaining contract balance to the owner.
        (bool os, ) = payable(owner()).call{value: address(this).balance}('');
        require(os);
    }
    // overrides.

    function _burn(uint256 tokenId) nonReentrant internal override(ERC721, ERC721URIStorage, ERC721Royalty) {
        require(ownerOf(tokenId) == msg.sender, "! owner");
        super._burn(tokenId);
    }

    function totalSupply() public view virtual returns (uint256) {
        return _tokenIdCounter.current();
    }
    
    function supportsInterface(bytes4 interfaceId) 
       public 
        view 
        virtual 
        override(ERC721, ERC721Royalty) 
        returns(bool) 
        {
            return super.supportsInterface(interfaceId);
        }
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}